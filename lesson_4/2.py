# Написать два алгоритма нахождения i-го по счёту простого числа.
# Без использования «Решета Эратосфена»;
# Используя алгоритм «Решето Эратосфена»

# Примечание ко всему домашнему заданию: Проанализировать скорость и сложность алгоритмов.
# # Результаты анализа сохранить в виде комментариев в файле с кодом.

import timeit


def erat(x, n):
    a = [0] * n
    for i in range(n):
        a[i] = i
    a[1] = 0
    m = 2
    while m < n:
        if a[m] != 0:
            j = m * 2
            while j < n:
                a[j] = 0
                j = j + m
        m += 1
    b = []
    for i in a:
        if a[i] != 0:
            b.append(a[i])
    return b[x - 1]


def cicle(x, n):
    count = 1
    for i in range(3, n):
        num = i
        lcount = 0
        for y in range(2, i):
            if num % y != 0:
                lcount += 1
            if lcount == (i - 2):
                count += 1
        if count == x:
            break
    return num


print(timeit.timeit("erat(29, 500)", setup="from __main__ import erat", number=10000))
print(timeit.timeit("cicle(29, 500)", setup="from __main__ import cicle", number=10000))

# при параметрах 29 простое число, в диапазоне от 2 до 250

# Время исполнения решеия через решето Эратосфена: 1.1070889910000001
# Время исполнения решеия через цикл: 5.753060994

# при параметрах 9 простое число, в диапазоне от 2 до 250

# Время исполнения решеия через решето Эратосфена: 0.7936545700000001
# Время исполнения решеия через цикл: 0.31492751399999996

# при параметрах 29 простое число, в диапазоне от 2 до 500

# Время исполнения решеия через решето Эратосфена: 1.63061698
# Время исполнения решеия через цикл: 5.5470814

# Насколько я понимаю:
# Замеры показывают что сложность алгоритмов разная. Если решение через цикл обладает линейной сложностью
# (чем большее число необходимо найти тем больше времени на поиск), то решение через решето Эратосфена зависит от размера "решета".
# В данном случае это означает квадратичную сложность. То есть сначала создается упорядоченный массив простых чисел,
# от размеров которого зависит время исполнения задачи. Потом в данном массиве ищется необходимый элемент
# (намного более простая и мнее затратная по времени операция)
